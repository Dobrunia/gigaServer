при старте игры есть меню с 1 кнопкой играть
в меню есть задний фон и стили для кнопки

при клике на играть игрок попадает в меню выбора персонажей
карточки персонажей со стпайтом персонажа слева и описанием персонажа справа
список персонажей храниться отдельно
описание это стартовые характеристики + прирост характеристик за уровень (как в доте)
тут отображаются такие характеристики:
макс хп + прирост за ур
броня + прирост за ур
скорость передвижения + прирост за ур
скорость применения заклинаний + прирост за ур
под этим указана уникальное пассивное умение его иконка слева + описание
список таких умений с характеристиками храниться отдельно
после выбора пользователю дают на выбор 1 активное умение из уникального списка
тоже карточки справйт + описание
после этого выбраный игроком персонаж попадает на карту (которая отрисовывается й раз в начале игры)
карта состоит из 1 текстуры (спрайта) по всей можно ходить
границы карты это белые линии за который хит бокс любого персонажа, моба или скила не может выйти
вот игра началась сверху по центру таймер
внизу худ (почти как в доте) иконка скилла который выбрал игрок и 3 пустые ячейки. А слева ТЕКУЩИЕ ( с учетом уровня и всех приростов) характеристики персонажа а также уровень и опыт персонажа (на старте 1 лвл 0 xp) макс хп, броня, скорость передвижения, скорость применения заклинаний
со старта в случайных местах на определенном удалении от игрока начинают спавниться мобы. мобы имеют хп, урон, армор, мувспид, тип атаки и хитбокс равный спрайту (модельки как у героев) мобы также имеют прирост статов за уровень разные типы мобов описанные в отдельном файле. В отличии от героев мобы получают прирост лвл в зависимости от текущего времени игры ( каждую минуту они повышают уровень).
есть моб ближнего боя, то как только хитбокс моба соприкосается с игроком то моб наносит урон игроку (тут нужно предусмотреть - скорость атаки сделай параметром)
если моб дальнего боя у него доп параметр это скорость палеты проджектаила, при атаке моб стреляет в определенный промежуток времени (тоже параметр скорости атаки) пуля имеет свой небольшой чекбокс летит всегда по прямой и может быть уничтожена в 3х случаях 1) попала по гринице карты 2) попала по игроку -> игрок получил 1 раз урон от моба. 3) превысила дальность полета
мобы ближнего боя с момента спавна бегут сократить дистанцию с игроком, чтобы ударить, мобы дальнего подходят на расстояние атаки (тоже спец параметр таких мобов) и стреляет по игроку.
Персонаж по кулдауну каста автоматически использует свои закленания (по ближайшийм противникав с любой стороны). напрявление атаки указывает небольшая стрелочка по кругу модельки персонажа, есть пользователь ЗАЖИМАЕТ (только, не 1 раз нажал) лкм или Левый стик на геймпаде (ps5 например) то персонаж начинает атаку в том напрввлении не зависимо есть там кто-то или нет
при ЗАЖАТОЙ пкм или правый стик, персонаж двигается по нанравлению
как только игрок отпускает пкм или стик движение останавливается, если отпускает лкм то персонаж переходит в режим самонаведения на ближайшую цель
из мобов падает опыт (тоже разное кол-во сказывается в файле с конфигами мобов)
если игрок подходит достаточно близко (параметр перса в конфиге) к выпавшему опыту то он его подбирает и прокачивается xp, если xp хватает уровень повышается, с повышением прирост статов и на выбор из 3х закленаний (в отдельном файле закленаний на выбор)
Все закленания делятся по след принципу есть 3 файла: врожденные закленания конкретных персонажей (отображаются иначе в худе снизу) тут важный момент эти закленания могут менять некоторые стандартные для всех персонажей вещи например добавлять +1 слот для активных скилов или добавлять возможность выбора из 4 скилов вместо 3х с повышением уровня (нужно учесть, это что некоторые стандартные вещи могут меняться для разных героев), первые закленания со старта (которые мы выбираем до старта игры, занимают 1ый слот из 4х по умолчанию), закленания за повышения уровня (они появляются в оставшихся пустых слотах).
Как во всех рогаликах тут важные моменты про закленания:
у заклинания могут быть характеристики: урон, кулдаун, радиус урона, дальность применения, длительность, эффекты котрые накладывают (замедление на % от скорости передвижения на вермя, яд (тикающий урон раз в 0.5 сек), руты (0% мувспид), стан - (руты + не может атаковть моб)) Все цыфры этих эффектов могут менятся в зависимости от врожденки перса. Те представим, есть перс у которого врожденка - "Все яд наносит урон на каждые 0.5 а каждые 0.2сек сохраняя длительность" те тут мы многократно увеличиваем дмг. Я это к тому, что при разработке нужно это учесть. Или длительность рутов дольше среднего и тд. Все эти эффекты отображаются над мобом если действуют на него, рядом в хп баром моба.
если закленание выпускает проджектаилы, то скорость этих проджектаилов
кстати по сути все умения пассивные (тк применяются по кд автоматически)
Во время игры раз в 10 мин появляется босс (описанны в спец файле и дроп с них)

Хорошо — даю компактный, практичный список оптимизаций и архитектурных решений для твоего roguelike на LÖVE, с учётом всего описанного (меню → выбор персонажа → карта, спавн мобов, скиллы, проектайлы, XP, боссы и т.п.). Разделил на «что делать» + «почему / эффект» + приоритет (высок/сред/низк).

Архитектура — модульная, data-driven

Разбить на модули (файлы/таблицы):

main.lua, conf.lua

assets.lua (загрузка, кеш)

ui/menu.lua, ui/char_select.lua, ui/hud.lua

map.lua (Canvas build, bounds)

entity/ (entity.lua, player.lua, mob.lua, projectile.lua)

skills/ (data + logic)

spawn_manager.lua

pool.lua (object pooling)

config/ (json/luas: mobs, heroes, skills, bosses)

save.lua
Почему: разделение ответственности, легко тестировать/редактировать контент. Приоритет: Высокий.

Data-driven конфиги: все статы/приросты/скиллы/мобы/боссы в JSON/Lua tables, не в коде.
Почему: быстрые правки баланса, перегрузка контента без компиляции. Приоритет: Высокий.

Рендер и графика

Отрисовка карты в Canvas один раз (или при изменении):

Build mapCanvas в love.load() или при смене уровня.

В love.draw() просто love.graphics.draw(mapCanvas).
Эффект: карта не перерисовывается по тайлу каждый кадр → большой выигрыш CPU/GPU. Приоритет: Высокий.

SpriteBatch для однотипных объектов (мобы/эффекты/опыт):

Если однотипные спрайты и одинаковые blend-режимы — рендерить через SpriteBatch.
Эффект: значительно меньше draw calls. Приоритет: Высокий.

Ограничение рендеринга (culling):

Не рисуй сущности вне камеры (AABB check camera).
Эффект: меньше операций draw/anim update. Приоритет: Высокий.

Атлас спрайтов + Quad:

Один большой spritesheet, фреймы через love.graphics.newQuad.
Эффект: быстрее рендер и можно использовать SpriteBatch. Приоритет: Средний.

Canvas масштабирование (для разных разрешений):

Рендерим сцену в фиксированный Canvas, потом масштабируем на экран — меньше перерасчетов. Приоритет: Низкий/Средний.

Обновления/логика / timestep

Фиксированный timestep для логики:

accumulator + fixed_dt = 1/60 для physics/AI/collision/damage. love.draw отдельно.
Эффект: детерминированность и стабильность скорости атаки/урона/стратегий. Приоритет: Высокий.

Делегирование частот обновлений:

AI/спавн/проверки дальности — не каждое fixed_dt. Например:

AI movement: 60Hz

Path decisions / target selection: 4–10Hz

Spawn logic: 1Hz или 0.2Hz
Эффект: снижает CPU при большом количестве мобов. Приоритет: Высокий.

Интерполяция для плавного рендера:

Если логика шаги фиксированы, интерполируй позицию для плавного draw. Приоритет: Средний.

Коллизии и поиск целей

Spatial hashing / uniform grid:

Разбить карту на сетку (ячейки), хранить сущностей по ячейкам — быстрый поиск ближайших/коллизий.
Эффект: O(1) локальный поиск вместо O(N). Приоритет: Высокий.

Упрощённая физика AABB:

Для хитбоксов используем AABB или круги; для тайлов — простая проверка по координате.
Эффект: быстро и предсказуемо. Приоритет: Высокий.

Объекты, GC и память

Object pooling для пуль/частиц/временных объектов:

Переиспользуй таблицы вместо {} каждый кадр.
Эффект: уменьшает сборки мусора и фризы. Приоритет: Высокий.

Минимизировать аллокации в update/draw:

Избегать создания таблиц/строк внутри цикла update/draw. Использовать локальные переменные. Приоритет: Высокий.

Контроль GC:

В профайле проверить collectgarbage("count"). При необходимости — раз в N секунд collectgarbage("step") с осторожностью. Приоритет: Средний.

AI / поведение мобов / скиллы

Лёгкие стейты AI + таймеры:

Для каждого моба минимальный state (idle, chase, attack) + таймер перехода. AI heavy work — раз в несколько тиков.
Эффект: простая логика = стабильно при большом количестве врагов. Приоритет: Высокий.

Параметризованные sKills (data-driven):

Все эффекты (тик-урон, длительности, мультипликаторы от врождёнки) — в конфиг. При применении эффектов — не создавай сотни таймеров: использовать структуру statusEffects с обновлением в fixed tick.
Эффект: удобство баланса и производительность. Приоритет: Высокий.

Projectiles: pooling + simple physics:

Хранить lifeTime, speed, direction vector; проверять collision via spatial hash; уничтожать при границе/хите/дальности.
Приоритет: Высокий.

UI / HUD / Меню / селекты

Меню/карточки — отдельный режим:

При переходе в меню уменьшать update частоты игрового мира (или паузить полностью). Загрузка ассетов до входа в игру.
Приоритет: Средний.

Отложенная загрузка ассетов:

Загрузить основной UI и персонажей on-demand (например, при открытии character select) — уменьшит время старта. Приоритет: Средний.

Звук и частицы

Пул эффектов звука/частиц:

Не создавай новые Source каждый раз, пересоздавай/перезапускай заранее созданные. Частицы — reuse ParticleSystem.
Приоритет: Средний.

Инструменты отладки и профилирования

Встроенный debug HUD:

FPS, кол-во сущностей, GC, ticks per second, max memory.
Приоритет: Высокий.

Логирование событий (ограниченное):

Логи критических ошибок/событий в файл, и краткие on-screen утилиты для включения/выключения логов. Приоритет: Средний.

Сохранение / сеть / конфигурация

Формат сохранения: JSON via love.filesystem (small, human-editable).
Приоритет: Средний.

Версии конфига: добавь version в config, чтобы мигрировать старые сейвы. Приоритет: Низкий.

Ввод и управление

Единая абстракция Input:

input.getMoveVector() объединяет клавиатуру и геймпад; обработка press vs hold.
Приоритет: Высокий.

Debounce / repeat handling:

Для LMB (aim/attack hold) и RMB (move hold) использовать isDown + state. Приоритет: Высокий.

Баланс и UX (особенно важно для автоматических умений)

Предсказуемость авто-каста:

Чёткие правила: автокаст выбирает ближайшую цель, при зажатии — override. Документировать в коде. Приоритет: Высокий.

Визуальные индикаторы:

Cooldown overlay, direction arrow, эффект-иконки над мобом (status stack). Эффект: улучшает UX и уменьшает вопросы игроков. Приоритет: Средний.
Приоритетный чеклист (быстрые выигрыши)

Canvas для карты — сделай первым. (High)

Pooling для пуль/частиц — (High)

Spatial hash для коллизий/поиска — (High)

Ограничение частоты AI/спавна — (High)

SpriteBatch для массовых одинаковых сущностей — (High)

Fixed timestep — (High)

Data-driven конфиги — (High)

Я даю тебе ТЗ (roguelike на LÖVE), далее — сгенерируй полную минимальную, но производительную и поддерживаемую структуру кода проекта на Lua (love2d). Требования к генерации:

1) Вывод: содержимое файлов проекта в виде отдельных блоков с именами файлов, например:
--- FILE: main.lua ---
<код>
--- FILE: conf.lua ---
<код>
и т.д.

2) Язык: Lua, совместимый с LÖVE 11.x / LuaJIT (стандарт Love2D). Не используй внешние C-библиотеки. Библиотеки на pure-Lua допустимы, но лучше — ноль внешних зависимостей.

3) Структура проекта (генерировать файлы/модули как минимум):
- conf.lua
- main.lua
- constants.lua — все параметры и "магические числа" как константы
- assets.lua — загрузка ресурсов, кеширование
- input.lua — абстракция для клавиатуры / геймпада (isDown, press, hold, getMoveVector)
- map.lua — сборка карты в Canvas, проверка границ
- camera.lua — простая камера (culling)
- spatial_hash.lua — реализация spatial hash / uniform grid для быстрых поисков
- pool.lua — generic object pool
- entity/base_entity.lua — базовый класс сущности (метатаблица), общие методы
- entity/player.lua — класс игрока (наследует base_entity)
- entity/mob.lua — класс моба (наследует base_entity) + AI states (idle,chase,attack)
- entity/projectile.lua — пуллинг, движение, столкновение
- skills.lua — обработка применения скиллов, эффектов, статус-эффектов (tick-based)
- spawn_manager.lua — логика спавна мобов по таймеру
- ui/menu.lua — меню/карточки выбора персонажа (режимы игры)
- ui/hud.lua — отображение HUD (HP, XP, скиллы)
- game.lua — основной гейм-стейт, fixed timestep loop, переключение режимов
- config/heroes.lua, config/mobs.lua, config/skills.lua, config/bosses.lua — data-driven конфиги (пример нескольких записей)
- utils.lua — утилиты (aabb, lerp, clamp, vec math, debug)
- README.md — краткая инструкция (команды запуска, структура)
(могешь добавить ещё небольшие модули если считаешь нужным, но обязательно укажи их в выводе)

4) Архитектурные и кодстайловые требования:
- **Разделение ответственности**: UI, логика мира, рендеринг, ввод, конфиги — в отдельных модулях.
- **Классы/наследование**: используй корректный Lua-подход через метатаблицы/конструкторы; избегай глобалей.
- **Без магических чисел**: все числовые параметры вынесены в constants.lua или конфиги; в коде используй именованные константы.
- **Паттерны**: объектный базовый класс для сущностей, пул объектов для пуль/частиц, spatial hash для поиска соседей, state machine для AI, dirty-flag + Canvas для статичных рендеров, spritebatch для однотипных draw.
- **Fixed timestep**: логика (AI, физика, коллизии) должна идти через фиксированный шаг (например 1/60). В draw использовать интерполяцию, если нужно.
- **Пуллинг**: пул для пуль и частиц; пример get/release.
- **Spatial hash**: пример добавления/удаления сущности, queryNearby(x,y,r).
- **Минимизация аллокаций**: избегать создания таблиц/строк в горячих циклах; локальные переменные; переиспользование объектов.
- **Комментарии**: подробные комментарии в коде (что делает блок, почему так сделано, где возможны улучшения).
- **Документация**: краткий README.md и комментарии к конфигам (формат записей).
- **Структура данных**: data-driven — конфиги содержат статы, приросты, параметры скиллов, поведение мобов.
- **Ошибки/логирование**: простой лог в файл и on-screen debug toggle; xpcall для безопасного выполнения основных циклов.
- **Тестируемость**: логические функции (тип calcXP, levelUp, damageCalc) вынести в utils или отдельный модуль, с понятными входами/выходами.

5) Игровая логика / особенности (должны быть в коде или в комментах):
- Карта — единая текстура, отрисованная в Canvas один раз.
- Границы карты: хитбокс не выходит за границы.
- Персонажи: стартовые характеристики + прирост за уровень (data-driven).
- Выбор персонажа: карточки (sprite + текст) — UI-модуль.
- Скиллы: пассивно/автоматически кастуются по CD на ближайшую цель; также поведение при удержании ЛКМ (промпт в input.lua).
- Эффекты: статусы (slow, dot, root, stun) — tick-based, data-driven, могут модифицироваться врождёнками; стек/refresh правила в comments.
- Мобы: разные типы (melee, ranged) с ростом уровня по таймеру минуты; дальние — проектайлы (через пул).
- Projectiles: lifeTime/distance/speed/direction, collision handling (hit player, hit bound, exceed range).
- XP: дроп, сбор (pickup radius config), level up + выбор из N скиллов (config-driven).
- Boss spawn: отдельно через spawn_manager (каждые N минут).

6) Производительность:
- Использовать Canvas для статичных слоёв, SpriteBatch для повторяющихся спрайтов.
- Culling через camera + spatial_hash.
- Частотная оптимизация: AI heavy ops не каждый кадр.
- Пуллинг для projectiles/particles
- Минимизировать GC: no allocations in hot paths.

7) Форма вывода конфигов:
- Включи 3-4 примера записей в config/heroes.lua, mobs.lua, skills.lua, bosses.lua с комментариями как расширять.

8) Стиль кода:
- Используй `local` везде; модули возвращают таблицу; имена функций понятны; читаемые переменные; короткие функции (<~50 строк); ясные interfaces (init, update, draw, reset).

9) Просьба по результату:
- В каждом файле добавь header-комментарий: назначение файла, публичный API, зависимости.
- В конце вывода сгенерируй краткий `TODO` список (3-5 пунктов) улучшений/фич для следующего шага (например: сетевой режим, редактор карт, автоматические тесты).
- Не добавляй внешних объяснений за пределами файловой структуры. Только блоки файлов.

10) Доп. ограничения:
- Код должен быть готов к запуску (минимальный рабочий skeleton), но не обязан содержать весь контент (спрайты) — используй placeholders в assets.lua и комментарии как подставить свои изображения.
- Не используй глобальные Require-пути типа `require 'libs.xxx'` без явного файла в списке.
- Учитывай, что проект будет запускаться в среде love2d локально через `love .`.

Сгенерируй проект по этим правилам, соблюдая лучшие практики love2d, ясную архитектуру и производительность. Пиши код аккуратно, с комментариями, без «магии» в числах — все в constants/config.
и т.д.

Забдь про код выше, требуется создать новый вид скилла который создает новое существо, которое атакует врагов скиллами
Skills["bear"] = {
    id = "bear",
    name = "Bear",
    description = "Summons a bear that attacks enemies",
    type = "summon",
    isStartingSkill = true,

    stats = {
        health = 100,
        armor = 5,
        moveSpeed = 80,
        cooldown = 25.0,
        duration = 30.0,  -- длительность существования
        followDistance = 500,  -- дистанция следования за героем
    },

    width = 64,
    height = 64,
    skills = {'zombie-cleave'},

    quads = {
        idle = {
            row = 1,
            col = 1
        },
        walk = {
            startrow = 1,
            startcol = 2,
            endrow = 1,
            endcol = 4
        },
        cast = {
            startrow = 1,
            startcol = 5,
            endrow = 1,
            endcol = 6
        }
    },
}
вот код который нужен для понимания
local MathUtils = {}
MathUtils.__index = MathUtils

function MathUtils.deepCopy(original)
    if type(original) ~= "table" then
        return original
    end
    
    local copy = {}
    for key, value in pairs(original) do
        copy[key] = MathUtils.deepCopy(value)
    end
    return copy
end

-- Вычисление расстояния между двумя точками
function MathUtils.distance(x1, y1, x2, y2)
    local dx = x2 - x1
    local dy = y2 - y1
    return math.sqrt(dx*dx + dy*dy)
end

-- Вычисление расстояния между двумя объектами
function MathUtils.distanceBetween(obj1, obj2)
    return MathUtils.distance(obj1.x, obj1.y, obj2.x, obj2.y)
end

-- Нормализация вектора
function MathUtils.normalize(x, y)
    local length = math.sqrt(x*x + y*y)
    if length > 0 then
        return x/length, y/length
    end
    return 0, 0
end

-- Направление от точки A к точке B
function MathUtils.direction(fromX, fromY, toX, toY)
    return MathUtils.normalize(toX - fromX, toY - fromY)
end

-- Направление от объекта A к объекту B
function MathUtils.directionBetween(from, to)
    return MathUtils.direction(from.x, from.y, to.x, to.y)
end

-- Проверка, находится ли точка в радиусе
function MathUtils.isInRange(x1, y1, x2, y2, range)
    return MathUtils.distance(x1, y1, x2, y2) <= range
end

-- Проверка, находится ли объект в радиусе от другого объекта
function MathUtils.isObjectInRange(obj1, obj2, range)
    return MathUtils.distanceBetween(obj1, obj2) <= range
end

-- Интерполяция между двумя значениями
function MathUtils.lerp(a, b, t)
    return a + (b - a) * t
end

-- Ограничение значения в диапазоне
function MathUtils.clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

-- Случайное число в диапазоне
function MathUtils.randomRange(min, max)
    return min + math.random() * (max - min)
end

-- Округление числа до указанного количества знаков после запятой
function MathUtils.round(num, decimals)
    if num == nil then
        return 0
    end
    local mult = 10^(decimals or 0)
    return math.floor(num * mult + 0.5) / mult
end

-- Форматирование времени в MM:SS
function MathUtils.formatTime(seconds)
    if seconds == nil then
        return "00:00"
    end
    local minutes = math.floor(seconds / 60)
    local secs = math.floor(seconds % 60)
    return string.format("%02d:%02d", minutes, secs)
end

-- Проверяет, пересекается ли круг с прямоугольником (хотя бы наполовину)
function MathUtils.circleIntersectsRect(circleX, circleY, radius, rectX, rectY, rectW, rectH)
    -- Находим ближайшую точку прямоугольника к центру круга
    local closestX = math.max(rectX, math.min(circleX, rectX + rectW))
    local closestY = math.max(rectY, math.min(circleY, rectY + rectH))
    
    -- Расстояние от центра круга до ближайшей точки прямоугольника
    local dx = circleX - closestX
    local dy = circleY - closestY
    local distance = math.sqrt(dx * dx + dy * dy)
    
    return distance <= radius
end

-- Проверяет, может ли атакующий попасть по цели навыком
function MathUtils.canAttackTarget(attacker, target, skillRange)
    local attackerCenterX = attacker.x + attacker.effectiveWidth * 0.5
    local attackerCenterY = attacker.y + attacker.effectiveHeight * 0.5
    local targetX = target.x
    local targetY = target.y
    local targetW = target.effectiveWidth
    local targetH = target.effectiveHeight
    
    return MathUtils.circleIntersectsRect(attackerCenterX, attackerCenterY, skillRange, 
                                        targetX, targetY, targetW, targetH)
end

-- Находит ближайшего противника в заданном радиусе
function MathUtils.findNearestOpponent(caster, world, maxDist)
    local list = (caster and caster.enemyId) and (world and world.heroes) or (world and world.enemies)
    if not list then return nil end
    local cx = caster.x + (caster.effectiveWidth or 0) * 0.5
    local cy = caster.y + (caster.effectiveHeight or 0) * 0.5
    local best, bestD2 = nil, (maxDist and maxDist*maxDist) or math.huge
    for i=1,#list do
        local t = list[i]
        if t and not t.isDead then
            local px = t.x + (t.effectiveWidth  or 0) * 0.5
            local py = t.y + (t.effectiveHeight or 0) * 0.5
            local dx, dy = px-cx, py-cy
            local d2 = dx*dx + dy*dy
            if d2 < bestD2 then
                best, bestD2 = {x=px,y=py}, d2
            end
        end
    end
    return best, math.sqrt(bestD2)
end

-- Поворот вектора на заданный угол (в радианах)
function MathUtils.rotateVector(x, y, angle)
    local ca, sa = math.cos(angle), math.sin(angle)
    return x*ca - y*sa, x*sa + y*ca
end

-- Проверяет, находится ли точка в секторе
function MathUtils.pointInSector(px, py, cx, cy, dx, dy, rMin, rMax, halfAngle)
    local vx, vy = px - cx, py - cy
    local dist2 = vx*vx + vy*vy
    if dist2 < rMin*rMin or dist2 > rMax*rMax then return false end
    local d = math.sqrt(dist2)
    if d < 1e-6 then return true end
    
    -- Нормализуем вектор от центра к точке
    vx, vy = vx/d, vy/d
    
    -- Вычисляем угол между направлением сектора и вектором к точке
    local dot = vx*dx + vy*dy
    if dot > 1 then dot = 1 elseif dot < -1 then dot = -1 end
    local angle = math.acos(dot)
    
    -- Проверяем, что угол меньше половины угла сектора
    -- halfAngle уже в радианах и представляет половину угла сектора
    return angle <= halfAngle
end

-- Проверяет, пересекается ли прямоугольник с сектором
function MathUtils.rectIntersectsSector(rectX, rectY, rectW, rectH, cx, cy, dx, dy, rMin, rMax, halfAngle)
    -- Проверяем углы прямоугольника
    local corners = {
        {rectX, rectY},                    -- левый верхний
        {rectX + rectW, rectY},            -- правый верхний
        {rectX, rectY + rectH},            -- левый нижний
        {rectX + rectW, rectY + rectH}     -- правый нижний
    }
    
    -- Проверяем центр прямоугольника
    local centerX = rectX + rectW * 0.5
    local centerY = rectY + rectH * 0.5
    table.insert(corners, {centerX, centerY})
    
    -- Если хотя бы одна точка попадает в сектор, считаем пересечение
    for _, corner in ipairs(corners) do
        if MathUtils.pointInSector(corner[1], corner[2], cx, cy, dx, dy, rMin, rMax, halfAngle) then
            return true
        end
    end
    
    -- Дополнительная проверка: если центр сектора находится внутри прямоугольника
    if centerX >= rectX and centerX <= rectX + rectW and 
       centerY >= rectY and centerY <= rectY + rectH then
        return true
    end
    
    return false
end

-- Получает направление от кастера к цели с учетом режима направления
function MathUtils.directionFromCaster(caster, tx, ty, followAim, directionMode)
    local cx = caster.x + (caster.effectiveWidth  or 0) * 0.5
    local cy = caster.y + (caster.effectiveHeight or 0) * 0.5
    local dx, dy
    
    if followAim then
        -- Вектор от кастера к цели
        dx, dy = tx - cx, ty - cy
    else
        dx = (caster.facing == -1) and -1 or 1
        dy = 0
    end

    if directionMode == "horizontal" then
        dx = (dx < 0) and -1 or 1
        dy = 0
    elseif directionMode == "vertical" then
        dx = 0
        dy = (cy - ty < 0) and -1 or 1
    end
    
    return MathUtils.normalize(dx, dy)
end

return MathUtils
local MathUtils   = require("src.utils.math_utils")
local Projectile  = require("src.entity.projectile")

-- types
local Melee = require("src.entity.skill_types.melee")
local Orbital = require("src.entity.skill_types.orbital")
local Aura = require("src.entity.skill_types.aura")

local Skill = {}
Skill.__index = Skill


-- скилл не наследник Object, он создаёт/управляет сущностями (проджектайлы, зоны и т.п.)
function Skill.new(skillId, level, caster)
    local self = setmetatable({}, Skill)

    local config = require("src.config.skills")[skillId]
    if not config then
        error("Skill config not found: " .. tostring(skillId))
    end

    self.id = config.id
    self.name = config.name
    self.description = config.description
    self.type = config.type
    self.level = level or 1
    self.maxLevel = (config.upgrades and #config.upgrades or 0) + 1
    self.isStartingSkill = config.isStartingSkill
    self.upgrades = MathUtils.deepCopy(config.upgrades or {})
    self.stats = MathUtils.deepCopy(config.stats or {})
    self.caster = caster or nil
    self.cooldownTimer = 0
    self.isOnCooldown = false
    self:applyCasterModifiers()

    return self
end

-- Применяем модификаторы кастера к базовым статам (например, CDR)
function Skill:applyCasterModifiers()
    if self.caster and self.caster.cooldownReduction and self.stats and self.stats.cooldown then
        self.stats.cooldown = self.stats.cooldown * (1 - self.caster.cooldownReduction)
    end
end

-- ==== КУЛДАУН ====
function Skill:canCast()
    return not self.isOnCooldown
end

function Skill:startCooldown()
    local cd = (self.stats and self.stats.cooldown) or 0
    if cd > 0 then
        self.isOnCooldown  = true
        self.cooldownTimer = cd
    else
        -- мгновенно готов снова
        self.isOnCooldown  = false
        self.cooldownTimer = 0
    end
end

-- Базовый каст без цели (оставлен для совместимости с бафами/аурами)
function Skill:cast()
    if not self:canCast() then
        return false
    end
    self:startCooldown()
    return true
end

-- Каст по точке: для projectile — спавним проджектайл и запускаем КД
function Skill:castAt(world, tx, ty)
    if not self:canCast() then
        return false
    end

    if self.type == "projectile" then
        if not (world and self.caster) then
            -- без мира/кастера проджектайл создать нельзя
            return false
        end

        Projectile.spawn(world, self.caster, self, tx, ty)
        self:startCooldown()
        return true

    elseif self.type == "melee" then
        if not (world and self.caster) then return false end
    
        -- если координаты не передали — автонаведение по ближайшей цели в пределах триггер-дистанции
        if tx == nil or ty == nil then
            local castRange = (self.stats and (self.stats.range or self.stats.arcRadius)) or 0
            local tgt, dist = MathUtils.findNearestOpponent(self.caster, world, castRange > 0 and castRange or nil)
            if not tgt then return false end
            -- если указан range, не кастуем, если цель слишком далеко
            if castRange > 0 and dist > castRange then return false end
            tx, ty = tgt.x, tgt.y
        end
    
        Melee.spawn(world, self.caster, self, tx, ty)
        self:startCooldown()
        return true

    elseif self.type == "volley" then
        if not (world and self.caster) then return false end
        
        local directions = self.stats.direction or 4
        local angleStep = (2 * math.pi) / directions
        
        -- Создаем проджектайлы в разных направлениях
        for i = 0, directions - 1 do
            local angle = i * angleStep
            local dirX = math.cos(angle)
            local dirY = math.sin(angle)
            
            -- Вычисляем целевую точку в направлении стрельбы
            local range = self.stats.range or 250
            local targetX = self.caster.x + (self.caster.effectiveWidth or 0) * 0.5 + dirX * range
            local targetY = self.caster.y + (self.caster.effectiveHeight or 0) * 0.5 + dirY * range
            
            Projectile.spawn(world, self.caster, self, targetX, targetY)
        end
        
        self:startCooldown()
        return true

    elseif self.type == "orbital" then
        if not (world and self.caster) then return false end
        
        -- Орбитальные скиллы кастуются автоматически по готовности (как ауры)
        -- Не требуют целей рядом, кастуются всегда когда не в КД
        Orbital.spawn(world, self.caster, self)
        self:startCooldown()
        return true

    elseif self.type == "aura" then
        if not (world and self.caster) then return false end
        
        -- Ауры кастуются автоматически по готовности
        -- Не требуют целей рядом, кастуются всегда когда не в КД
        Aura.spawn(world, self.caster, self)
        self:startCooldown()
        return true
    end

    -- другие типы добавим позже (aoe/instant и т.д.)
    return self:cast()
end

-- ==== ТИК КУЛДАУНА ====
function Skill:update(dt)
    if self.isOnCooldown then
        self.cooldownTimer = self.cooldownTimer - dt
        if self.cooldownTimer <= 0 then
            self.isOnCooldown  = false
            self.cooldownTimer = 0
        end
    end
end

-- ==== ПРОКАЧКА ====
function Skill:applyUpgrades(level)
    -- применяем все апгрейды до текущего уровня включительно (кроме базового)
    local targetLevel = math.min(level - 1, #self.upgrades)
    for i = 1, targetLevel do
        for key, value in pairs(self.upgrades[i]) do
            self.stats[key] = value
        end
    end
end

function Skill:canLevelUp()
    return self.level < self.maxLevel
end

function Skill:levelUp()
    if not self:canLevelUp() then
        return
    end
    self.level = self.level + 1
    self:applyUpgrades(self.level)
end

function Skill:getStatValue(statName)
    if not self.stats or self.stats[statName] == nil then
        error("Stat not found: " .. tostring(statName))
    end
    return self.stats[statName]
end

-- Получить радиус навыка для отрисовки
function Skill:getRange()
    return self.stats and self.stats.range or 0
end

function Skill:getCooldownDuration()
    return (self.stats and self.stats.cooldown) or 0
end

function Skill:getCooldownRemaining()
    return self.cooldownTimer or 0
end

function Skill:isOnCD()
    return self.isOnCooldown and (self.cooldownTimer or 0) > 0
end


return Skill
local Spawner = require("src.world.spawner")
local Hero = require("src.entity.hero")
local Projectile = require("src.entity.projectile")
local DamageManager = require("src.system.damage_manager")
local Constants = require("src.constants")
local Melee = require("src.entity.skill_types.melee")
local Orbital = require("src.entity.skill_types.orbital")
local Aura = require("src.entity.skill_types.aura")

local World = {}
World.__index = World

function World.new(mapWidth, mapHeight)
    local self = setmetatable({}, World)
    self.width = mapWidth
    self.height = mapHeight

    self.heroes = {}
    self.enemies = {}
    self.drops = {}
    
    -- Статистика
    self.enemiesKilled = 0
    
    -- Создаем менеджер урона только если включена отладка
    if Constants.DEBUG_DRAW_DAMAGE_NUMBERS then
        self.damageManager = DamageManager.new()
    else
        self.damageManager = nil
    end

    self.spawner = Spawner.new(self.width, self.height)

    -- если где-то остались старые вызовы addProjectile, не упадём
    self._legacyProjectiles = {}

    return self
end

function World:setup(selectedHeroId, selectedSkillId, mapWidth, mapHeight)
    if mapWidth  then self.width  = mapWidth  end
    if mapHeight then self.height = mapHeight end
    if self.spawner and self.spawner.resize then
        self.spawner:resize(self.width, self.height)
    end

    -- Герой в центре карты
    local cx = (self.width  or 0) * 0.5
    local cy = (self.height or 0) * 0.5
    local hero = Hero.new(cx, cy, selectedHeroId, 1)

    -- Выбранный стартовый скилл
    if selectedSkillId then
        hero:addSkill(selectedSkillId, 1)
    end

    self:addHero(hero)
end

-- ==== Добавление сущностей ====
function World:addHero(hero)
    hero.world = self
    table.insert(self.heroes, hero)
end

function World:addEnemy(enemy)
    enemy.world = self
    table.insert(self.enemies, enemy)
end

-- Оставлено для совместимости: если где-то вручную создают projectile-объекты
function World:addProjectile(projectile)
    -- Централизованное управление проджектайлами находится в Projectile.updateAll/drawAll().
    -- Этот список оставлен, чтобы не ломать старые места вызова.
    table.insert(self._legacyProjectiles, projectile)
end

function World:addDrop(drop)
    table.insert(self.drops, drop)
end

-- ==== Апдейт ====
function World:update(dt)
    -- Герои
    for i = 1, #self.heroes do
        self.heroes[i]:update(dt)
    end

    -- Враги (с передачей первого героя как цели для AI)
    local hero = self.heroes[1]
    for i = 1, #self.enemies do
        self.enemies[i]:update(dt, hero)
    end

    -- Проджектайлы из пула (главный путь)
    Projectile.updateAll(dt, self)
    Melee.updateAll(dt, self)
    Orbital.updateAll(dt, self)
    Aura.updateAll(dt, self)

    -- Совместимость: если кто-то вручную добавил projectile-объекты
    -- требующие update — поддержим
    for i = #self._legacyProjectiles, 1, -1 do
        local p = self._legacyProjectiles[i]
        if p.update then p:update(dt, self) end
        if (p.isDead and p:isDead()) or p.active == false then
            table.remove(self._legacyProjectiles, i)
        end
    end

    -- Дропы
    for i = #self.drops, 1, -1 do
        local d = self.drops[i]
        d:update(dt, hero)
        if d.collected then
            table.remove(self.drops, i)
        end
    end

    -- Спавнер (если есть герой)
    if hero then
        self.spawner:update(dt, self, hero)
    end

    -- Обновляем цифры урона
    if self.damageManager then
        self.damageManager:update(dt)
    end

    -- Очистка умерших врагов (если кто-то не удалил сам)
    for i = #self.enemies, 1, -1 do
        if self.enemies[i].isDead then
            self.enemiesKilled = self.enemiesKilled + 1
            table.remove(self.enemies, i)
        end
    end
end

-- ==== Рендер ====
function World:draw()
    -- Порядок слоёв можно менять по вкусу
    -- 1) Герои
    for i = 1, #self.heroes do
        self.heroes[i]:draw()
    end

    -- 2) Враги
    for i = 1, #self.enemies do
        self.enemies[i]:draw()
    end

    -- 3) Проджектайлы из пула
    Projectile.drawAll()
    Melee.drawAll()
    Orbital.drawAll()
    Aura.drawAll()

    -- 4) Дропы
    for i = 1, #self.drops do
        self.drops[i]:draw()
    end

    -- 5) Совместимость: вручную добавленные проджектайлы
    for i = 1, #self._legacyProjectiles do
        local p = self._legacyProjectiles[i]
        if p.draw then p:draw() end
    end

    -- 6) Цифры урона (поверх всего)
    if self.damageManager then
        self.damageManager:draw()
    end
end

return World
local Creature = require("src.entity.creature")
local SpriteManager = require("src.utils.sprite_manager")
local MathUtils = require("src.utils.math_utils")
local Drop = require("src.entity.drop")

local Enemy = {}
Enemy.__index = Enemy
setmetatable(Enemy, {__index = Creature})

function Enemy.new(x, y, enemyId, level)
    local spriteSheet = SpriteManager.loadEnemySprite(enemyId)
    local config = require("src.config.enemies")[enemyId]
    if not config then error("Enemy config not found: " .. enemyId) end

    local self = Creature.new(spriteSheet, x, y, config, level)
    setmetatable(self, Enemy)

    self.enemyId    = config.id
    self.enemyName  = config.name
    self.dropConfig = config.drop
    self._config    = config

    -- добавим все скиллы моба
    if config.skills then
        for _, skillId in ipairs(config.skills) do
            self:addSkill(skillId, level or 1)
        end
    end

    -- таймер "зависания" на кадре атаки
    self._attackAnimTimer = 0
    -- длительность удержания кадра каста (можно переопределить в enemies.lua полем castHold)
    self._castHold = config.castHold or 0.3

    return self
end

-- минимальная дистанция, чтобы можно было кастовать хоть что-то (готовое в приоритете)
function Enemy:getDesiredStopDistance()
    local minReady, minAny
    if self.skills then
        for _, sk in ipairs(self.skills) do
            local r
            if sk.type == "melee" then
                -- для melee используем arcRadius вместо range (это реальный радиус поражения)
                r = sk.stats and (sk.stats.arcRadius or sk.stats.range)
            else
                r = sk.stats and sk.stats.range
            end
            
            if r then
                if sk:canCast() then
                    minReady = (minReady and math.min(minReady, r)) or r
                end
                minAny = (minAny and math.min(minAny, r)) or r
            end
        end
    end
    return minReady or minAny or 180
end

-- попытка кастануть любой готовый скилл, который достаёт до героя
function Enemy:tryCastAt(hero)
    if not (self.skills and hero) then return false end

    for _, sk in ipairs(self.skills) do
        local r
        if sk.type == "melee" then
            -- для melee используем arcRadius вместо range (это реальный радиус поражения)
            r = sk.stats and (sk.stats.arcRadius or sk.stats.range)
        else
            r = sk.stats and sk.stats.range
        end
        
        if r and sk:canCast() then
            local canHit = MathUtils.canAttackTarget(self, hero, r)
            
            -- Для melee навыков добавляем более простую проверку дистанции
            if sk.type == "melee" and not canHit then
                local dx = hero.x - self.x
                local dy = hero.y - self.y
                local dist = math.sqrt(dx*dx + dy*dy)
                canHit = dist <= r
            end
            
            if canHit then
            -- смотреть на цель
            local dx = hero.x - self.x
            local dy = hero.y - self.y
            if dx < -0.001 then self.facing = -1
            elseif dx > 0.001 then self.facing = 1 end

            -- анимация каста: если есть — включаем и "замораживаем" позицию
            if self.animationsList and self.animationsList["cast"] then
                self:playAnimation("cast")
                self._attackAnimTimer = self._castHold
            end

            -- запускаем скилл - передаем центр хитбокса героя, а не угол
            local heroCenterX = hero.x + (hero.effectiveWidth or 0) * 0.5
            local heroCenterY = hero.y + (hero.effectiveHeight or 0) * 0.5
            sk:castAt(self.world, heroCenterX, heroCenterY)
            return true
            end
        end
    end
    return false
end

function Enemy:update(dt, hero)
    if self.isDead then return end

    -- тикает удержание кадра каста
    if self._attackAnimTimer and self._attackAnimTimer > 0 then
        self._attackAnimTimer = self._attackAnimTimer - dt
        -- пока "кастуем" — не двигаемся (freeze)
        Creature.update(self, dt)
        return
    else
        -- сбрасываем анимацию каста когда таймер закончился
        if self.currentAnimation == "cast" then
            self:playAnimation("idle")
        end
    end

    if hero then
        local dx, dy = hero.x - self.x, hero.y - self.y
        local dist = math.sqrt(dx*dx + dy*dy)

        local stopDist = self:getDesiredStopDistance()
        -- Для melee навыков нужен меньший гистерезис, чтобы подойти ближе
        local hasMelee = false
        if self.skills then
            for _, sk in ipairs(self.skills) do
                if sk.type == "melee" then
                    hasMelee = true
                    break
                end
            end
        end
        local hyst = hasMelee and 2 or 8  -- меньший гистерезис для melee
        local stopWithHyst = math.max(0, stopDist - hyst)

        if dist > stopWithHyst and dist > 0.0001 then
            -- идём к герою (через changePosition -> флип и walk сработают)
            local nx, ny = dx / dist, dy / dist
            local step = (self.moveSpeed or self.baseMoveSpeed or 60) * dt
            local need = dist - stopWithHyst
            if step > need then step = need end
            self:changePosition(nx * step, ny * step)
        else
            -- уже на позиции — пытаемся кастовать
            self:tryCastAt(hero)
        end
    end

    -- базовые апдейты (скиллы/дебаффы/анимации walk/idle)
    Creature.update(self, dt)
end

function Enemy:die()
    Creature.die(self)
    self:createDrop()
end

function Enemy:createDrop()
    if not (self.dropConfig and self.world) then return end
    local drop = Drop.new(self.x, self.y, self.dropConfig, self.level or 1)
    self.world:addDrop(drop)
end

return Enemy
local Creature = require("src.entity.creature")
local SpriteManager = require("src.utils.sprite_manager")
local MathUtils = require("src.utils.math_utils")
local Constants = require("src.constants")

local Hero = {}
Hero.__index = Hero
setmetatable(Hero, {__index = Creature})

function Hero.new(x, y, heroId, level)
    local spriteSheet = SpriteManager.loadHeroSprite(heroId)
    local config = require("src.config.heroes")[heroId]
    if not config then
        error("Hero config not found: " .. heroId)
    end

    local self = Creature.new(spriteSheet, x, y, config, level or 1)
    setmetatable(self, Hero)

    -- базовое
    self.heroId = config.id
    self.heroName = config.name
    self.innateSkill = MathUtils.deepCopy(config.innateSkill)

    self.experience = 0
    self.experienceToNext = 100
    self.damageDealt = 0

    -- анимация каста
    self._castAnimTimer = 0
    self._castHold = 0.3

    -- === РЕЖИМ ПРИЦЕЛИВАНИЯ (ЛКМ ЗАЖАТА) ===
    self.aimOverride = false
    self.aimX, self.aimY = self.x, self.y

    return self
end

-- публичный API для игры: включить прицеливание от курсора
function Hero:setAimPoint(worldX, worldY)
    self.aimOverride = true
    self.aimX, self.aimY = worldX, worldY
end

-- выключить прицеливание (вернуться к авто-таргету)
function Hero:clearAim()
    self.aimOverride = false
end

function Hero:gainExperience(amount)
    self.experience = self.experience + amount
    if self.experience >= self.experienceToNext then
        self:levelUp()
    end
end

function Hero:dealDamage(amount)
    self.damageDealt = self.damageDealt + amount
end

function Hero:levelUp()
    self.level = self.level + 1
    self.experience = 0  -- очищаем опыт при повышении уровня
    self.experienceToNext = self.experienceToNext * 1.3

    self.baseHp = self.baseHp + self.hpGrowth
    self.hp = self.hp + self.hpGrowth
    self.baseArmor = self.baseArmor + self.armorGrowth
    self.armor = self.armor + self.armorGrowth
    self.baseMoveSpeed = self.baseMoveSpeed + self.speedGrowth
    self.moveSpeed = self.moveSpeed + self.speedGrowth
end

function Hero:getStats()
    return {
        level = self.level,
        hp = self.hp,
        maxHp = self.baseHp,
        xp = self.experience,
        xpToNext = self.experienceToNext,
        armor = self.armor,
        armorGrowth = self.armorGrowth,
        speed = self.moveSpeed,
        speedGrowth = self.speedGrowth,
    }
end

-- Найти ближайшего врага в радиусе хотя бы одного направленного скилла
function Hero:findNearestEnemyInRange()
    if not self.world or not self.world.enemies then
        return nil
    end
    local nearestEnemy, nearestDist = nil, math.huge

    for _, enemy in ipairs(self.world.enemies) do
        if enemy and not enemy.isDead then
            local dx, dy = (enemy.x - self.x), (enemy.y - self.y)
            local dist = math.sqrt(dx*dx + dy*dy)
            -- есть ли у героя хоть один скилл с радиусом > 0
            for _, skill in ipairs(self.skills) do
                local range = (skill.stats and skill.stats.range) or 0
                if range > 0 and MathUtils.canAttackTarget(self, enemy, range) and dist < nearestDist then
                    nearestEnemy, nearestDist = enemy, dist
                    break
                end
            end
        end
    end
    return nearestEnemy
end

-- Каст анимации + поворот
function Hero:_faceAndPlayCast(targetX, targetY)
    local dx = targetX - self.x
    if dx < -0.001 then
        self.facing = -1
    elseif dx > 0.001 then
        self.facing = 1
    end
    if self.animationsList and self.animationsList["cast"] then
        self:playAnimation("cast")
        self._castAnimTimer = self._castHold
    end
end

-- Автоатака / прицельная атака
function Hero:_attackLogic()
    if not self.world then return end

    if self.aimOverride then
        -- РЕЖИМ ПРИЦЕЛИВАНИЯ: кастуем ВСЕ направленные скиллы, которые готовы
        local tx, ty = self.aimX, self.aimY
        
        -- Просто поворачиваемся к цели без анимации
        local dx = tx - self.x
        if dx < -0.001 then
            self.facing = -1
        elseif dx > 0.001 then
            self.facing = 1
        end

        for _, skill in ipairs(self.skills) do
            -- считаем направленными скиллы типа "projectile" и "melee"
            -- орбитальные скиллы не кастуются в режиме прицеливания
            if (skill.type == "projectile" or skill.type == "melee") and skill:canCast() then
                -- Играем анимацию только при успешном касте
                self:_faceAndPlayCast(tx, ty)
                skill:castAt(self.world, tx, ty)
            end
        end
        return
    end

    -- АВТОЦЕЛЬ: ближайшая цель и первый доступный подходящий скилл
    local target = self:findNearestEnemyInRange()
    if not target then return end

    for _, skill in ipairs(self.skills) do
        -- Орбитальные скиллы и ауры уже кастуются автоматически в Creature.update()
        if skill.type ~= "orbital" and skill.type ~= "aura" and skill:canCast() then
            local range = (skill.stats and skill.stats.range) or 0
            if range > 0 and MathUtils.canAttackTarget(self, target, range) then
                self:_faceAndPlayCast(target.x, target.y)
                skill:castAt(self.world, target.x, target.y)
                return
            end
        end
    end
end

function Hero:update(dt)
    if self.isDead then return end

    if self._castAnimTimer and self._castAnimTimer > 0 then
        self._castAnimTimer = self._castAnimTimer - dt
        Creature.update(self, dt)
        return
    else
        if self.currentAnimation == "cast" then
            self:playAnimation("idle")
        end
    end

    Creature.update(self, dt)

    -- атака: либо по прицелу, либо по ближайшему
    if not self.isDead then
        self:_attackLogic()
    end
end

function Hero:draw()
    -- Вызываем базовую отрисовку из Creature
    Creature.draw(self)
    
    -- Рисуем стрелку направления если включена отладка
    if Constants.DEBUG_DRAW_DIRECTION_ARROW then
        self:drawDirectionArrow()
    end
end

function Hero:drawDirectionArrow()
    if self.isDead then return end
    
    local centerX = self.x + self.effectiveWidth * 0.5
    local centerY = self.y + self.effectiveHeight * 0.5
    
    if self.aimOverride then
        -- Рисуем стрелку к точке прицеливания
        local dx = self.aimX - centerX
        local dy = self.aimY - centerY
        local distance = math.sqrt(dx * dx + dy * dy)
        
        if distance > 10 then -- минимальное расстояние для отображения стрелки
            local arrowLength = math.min(100, distance * 0.5)
            local arrowEndX = centerX + (dx / distance) * arrowLength
            local arrowEndY = centerY + (dy / distance) * arrowLength
            
            -- Основная линия стрелки
            love.graphics.setColor(1, 1, 0, 0.8) -- желтый
            love.graphics.setLineWidth(3)
            love.graphics.line(centerX, centerY, arrowEndX, arrowEndY)
            
            -- Наконечник стрелки
            local arrowHeadSize = 8
            local angle = math.atan2(dy, dx)
            local headX1 = arrowEndX - arrowHeadSize * math.cos(angle - 0.5)
            local headY1 = arrowEndY - arrowHeadSize * math.sin(angle - 0.5)
            local headX2 = arrowEndX - arrowHeadSize * math.cos(angle + 0.5)
            local headY2 = arrowEndY - arrowHeadSize * math.sin(angle + 0.5)
            
            love.graphics.line(arrowEndX, arrowEndY, headX1, headY1)
            love.graphics.line(arrowEndX, arrowEndY, headX2, headY2)
            
            love.graphics.setLineWidth(1)
            love.graphics.setColor(1, 1, 1, 1)
        end
    else
        -- Рисуем стрелку к ближайшему врагу
        local target = self:findNearestEnemyInRange()
        if target then
            local dx = target.x - centerX
            local dy = target.y - centerY
            local distance = math.sqrt(dx * dx + dy * dy)
            
            if distance > 10 then
                local arrowLength = math.min(80, distance * 0.4)
                local arrowEndX = centerX + (dx / distance) * arrowLength
                local arrowEndY = centerY + (dy / distance) * arrowLength
                
                -- Основная линия стрелки (зеленая для автоатаки)
                love.graphics.setColor(0, 1, 0, 0.6) -- зеленый
                love.graphics.setLineWidth(2)
                love.graphics.line(centerX, centerY, arrowEndX, arrowEndY)
                
                -- Наконечник стрелки
                local arrowHeadSize = 6
                local angle = math.atan2(dy, dx)
                local headX1 = arrowEndX - arrowHeadSize * math.cos(angle - 0.5)
                local headY1 = arrowEndY - arrowHeadSize * math.sin(angle - 0.5)
                local headX2 = arrowEndX - arrowHeadSize * math.cos(angle + 0.5)
                local headY2 = arrowEndY - arrowHeadSize * math.sin(angle + 0.5)
                
                love.graphics.line(arrowEndX, arrowEndY, headX1, headY1)
                love.graphics.line(arrowEndX, arrowEndY, headX2, headY2)
                
                love.graphics.setLineWidth(1)
                love.graphics.setColor(1, 1, 1, 1)
            end
        end
    end
end

return Hero
-- src/entity/skill_types/melee.lua
-- ближний удар (сектор/круг), с ограничением направления: free / horizontal / vertical

local MathUtils = require("src.utils.math_utils")

local Melee = {}
Melee.__index = Melee

local _pool  = {}
local _alive = {}

-- ================== helpers ==================

local function _normalize(x, y)
    local d = math.sqrt(x*x + y*y)
    if d < 1e-6 then return 0, 0 end
    return x/d, y/d
end


-- ================== ctor ==================

local function _build(world, caster, skill, tx, ty)
    local self = {
        _dead = false,
        world  = world,
        caster = caster,
        skill  = skill,
        timer  = 0,
        didHit = false,
    }
    setmetatable(self, Melee)

    local st = skill.stats or {}

    -- тайминги
    self.windup = st.windup or 0
    self.active = st.active or 0

    -- геометрия
    self.arcAngle  = math.rad(st.arcAngleDeg or 90)
    self.halfAngle = self.arcAngle * 0.5
    self.arcRadius = st.arcRadius or 60
    self.arcInner  = st.arcInnerRadius or 0
    self.arcOffset = math.rad(st.arcOffsetDeg or 0)

    -- поведение
    self.followAim         = (st.followAim ~= false)
    self.trackDuringWindup = false            -- ВАЖНО: во время замаха ничего не «подтягиваем»
    self.lockMovement      = (st.lockMovement ~= false)
    self.directionMode     = st.directionMode or "free"
    self.centerOffset      = st.centerOffset or 0

    -- визуал
    self.color = st.telegraphColor or {1,1,1}
    self.alpha = st.telegraphAlpha or 0.15

    -- стартовые центр/направление
    self.centerX = caster.x + (caster.effectiveWidth  or 0) * 0.5
    self.centerY = caster.y + (caster.effectiveHeight or 0) * 0.5
    self.dirX, self.dirY = MathUtils.directionFromCaster(caster, tx, ty, self.followAim, self.directionMode)

    -- сохраняем "снимок" на старте (именно эти значения и рисуем, и бьём)
    self.fixedCenterX, self.fixedCenterY = self.centerX, self.centerY
    self.fixedDirX,    self.fixedDirY    = self.dirX, self.dirY

    if self.centerOffset ~= 0 then
        self.centerX = self.centerX + self.dirX * self.centerOffset
        self.centerY = self.centerY + self.dirY * self.centerOffset
    end

    if not self.trackDuringWindup then
        self.fixedCenterX, self.fixedCenterY = self.centerX, self.centerY
        self.fixedDirX,    self.fixedDirY    = self.dirX, self.dirY
    end

    -- боевые
    self.hitMaxTargets = st.hitMaxTargets or 0
    self.knockback     = st.knockback or 0

    return self
end

function Melee.spawn(world, caster, skill, tx, ty)
    local self = table.remove(_pool)
    if self then
        -- реинициализация в существующий объект пула
        for k in pairs(self) do self[k] = nil end
        local fresh = _build(world, caster, skill, tx, ty)
        for k,v in pairs(fresh) do self[k] = v end
        setmetatable(self, Melee)   -- <-- гарантируем метатаблицу
    else
        self = _build(world, caster, skill, tx, ty)
    end
    self._dead = false              -- <-- обязательно сбрасываем
    table.insert(_alive, self)
    
    -- Заморозка кастера на время замаха (и фейс не менять)
    if self.lockMovement and caster then
        if caster.lockMovement then caster:lockMovement(self.windup or 0) end
        if caster.lockFacing  then caster:lockFacing(self.windup or 0)  end
        if caster.animationsList and caster.animationsList["cast"] then
            caster:playAnimation("cast")
        end
    end
    
    return self
end

-- ================== logic ==================

function Melee:_applyHit()
    local st = self.skill.stats or {}
    local dmg = st.damage or 0

    local cx = self.fixedCenterX or self.centerX
    local cy = self.fixedCenterY or self.centerY
    local dx = self.fixedDirX    or self.dirX
    local dy = self.fixedDirY    or self.dirY
    dx, dy = MathUtils.rotateVector(dx, dy, self.arcOffset)

    local targets = (self.caster and self.caster.enemyId) and (self.world and self.world.heroes) or (self.world and self.world.enemies)
    if not targets then return end

    local hits = 0
    for i = 1, #targets do
        local t = targets[i]
        if t and not t.isDead then
            local rectX = t.x
            local rectY = t.y
            local rectW = t.effectiveWidth or 0
            local rectH = t.effectiveHeight or 0
            
            -- Проверяем несколько точек внутри хитбокса цели
            local points = {
                -- Центр
                {rectX + rectW * 0.5, rectY + rectH * 0.5},
                -- Углы
                {rectX, rectY},
                {rectX + rectW, rectY},
                {rectX, rectY + rectH},
                {rectX + rectW, rectY + rectH},
                -- Середины сторон
                {rectX + rectW * 0.5, rectY},
                {rectX + rectW * 0.5, rectY + rectH},
                {rectX, rectY + rectH * 0.5},
                {rectX + rectW, rectY + rectH * 0.5}
            }
            
            local hit = false
            for _, point in ipairs(points) do
                if MathUtils.pointInSector(point[1], point[2], cx, cy, dx, dy, self.arcInner, self.arcRadius, self.halfAngle) then
                    hit = true
                    break
                end
            end
            
            if hit then
                local px = rectX + rectW * 0.5
                local py = rectY + rectH * 0.5
                if t.takeDamage then t:takeDamage(dmg) end
                if self.knockback > 0 and t.changePosition then
                    local kx, ky = _normalize(px - cx, py - cy)
                    t:changePosition(kx * self.knockback, ky * self.knockback)
                end
                hits = hits + 1
                if self.hitMaxTargets > 0 and hits >= self.hitMaxTargets then break end
            end
        end
    end
end

function Melee:update(dt)
    self.timer = self.timer + dt

    -- Никакого «прилипания»: используем фиксированные значения
    if not self.didHit and self.timer >= self.windup then
        self.didHit = true
        self:_applyHit()
    end

    if self.timer >= self.windup + self.active then
        self:dispose()
    end
end

-- ================== draw ==================

function Melee:draw()
    local cx = self.fixedCenterX or self.centerX
    local cy = self.fixedCenterY or self.centerY
    local dx = self.fixedDirX    or self.dirX
    local dy = self.fixedDirY    or self.dirY
    local baseAng = math.atan2(dy, dx) + self.arcOffset
    local a1, a2 = baseAng - self.halfAngle, baseAng + self.halfAngle

    -- Вычисляем прогресс заполнения (0 = только контур, 1 = полностью заполнен)
    local progress = 0
    if self.timer < self.windup then
        -- Во время windup заполняем от 0 до 1
        progress = self.timer / self.windup
    else
        -- После windup полностью заполнен
        progress = 1
    end

    -- Рисуем контур сектора
    love.graphics.setColor(self.color[1], self.color[2], self.color[3], self.alpha * 0.5)
    love.graphics.arc("line", cx, cy, self.arcRadius, a1, a2, 32)
    
    -- Рисуем заполнение сектора в зависимости от прогресса
    if progress > 0 then
        local fillRadius = self.arcRadius * progress
        love.graphics.setColor(self.color[1], self.color[2], self.color[3], self.alpha)
        
        if self.arcInner > 0 then
            -- Для дуги с внутренним радиусом
            love.graphics.arc("fill", cx, cy, fillRadius, a1, a2)
            love.graphics.setColor(0, 0, 0, 1) -- черный для "вырезания" внутренней части
            love.graphics.arc("fill", cx, cy, self.arcInner, a1, a2)
        else
            -- Обычный сектор
            love.graphics.arc("fill", cx, cy, fillRadius, a1, a2)
        end
    end

    -- Рисуем направление атаки (стрелка)
    if progress > 0.5 then
        local arrowLength = 20
        local arrowEndX = cx + dx * arrowLength
        local arrowEndY = cy + dy * arrowLength
        
        love.graphics.setColor(1, 1, 0, 0.8) -- желтая стрелка
        love.graphics.setLineWidth(3)
        love.graphics.line(cx, cy, arrowEndX, arrowEndY)
        
        -- Наконечник стрелки
        local arrowHeadSize = 6
        local angle = math.atan2(dy, dx)
        local headX1 = arrowEndX - arrowHeadSize * math.cos(angle - 0.5)
        local headY1 = arrowEndY - arrowHeadSize * math.sin(angle - 0.5)
        local headX2 = arrowEndX - arrowHeadSize * math.cos(angle + 0.5)
        local headY2 = arrowEndY - arrowHeadSize * math.sin(angle + 0.5)
        
        love.graphics.line(arrowEndX, arrowEndY, headX1, headY1)
        love.graphics.line(arrowEndX, arrowEndY, headX2, headY2)
        love.graphics.setLineWidth(1)
    end

    love.graphics.setColor(1, 1, 1, 1)
end

-- ================== pool ==================

function Melee:isDead() return self._dead end

function Melee:dispose()
    self._dead = true
    self.world, self.caster, self.skill = nil, nil, nil
    table.insert(_pool, self)
end

function Melee.updateAll(dt, world)
    for i = #_alive, 1, -1 do
        local m = _alive[i]
        -- защита от «битых» записей
        if not m or not m.update then
            table.remove(_alive, i)
        else
            m:update(dt)
            if m:isDead() then table.remove(_alive, i) end
        end
    end
end

function Melee.drawAll()
    for i = 1, #_alive do
        local m = _alive[i]
        if m and m.draw then m:draw() end
    end
end

return Melee
